package main

import "fmt"

func main() {
	var x, y, z uint8

	x = 9
	y = 28
	z = x

	fmt.Println("Битовые операции")

	fmt.Printf("^x      = ^(%d)      = ^(%.8b)            = %.8b = %d\n", x, x, ^x, ^x)
	fmt.Printf("x << 2  = (%d << 2)  = (%.8b << 2)        = %.8b = %d\n", x, x, x<<2, x<<2)
	fmt.Printf("x >> 2  = (%d >> 2)  = (%.8b >> 2)        = %.8b = %d\n", x, x, x>>2, x>>2)
	fmt.Printf("x & y   = (%d & %d)  = (%.8b & %.8b)  = %.8b = %d\n", x, y, x, y, x&y, x&y)
	fmt.Printf("x | y   = (%d | %d)  = (%.8b | %.8b)  = %.8b = %d\n", x, y, x, y, x|y, x|y)
	fmt.Printf("x ^ y   = (%d ^ %d)  = (%.8b ^ %.8b)  = %.8b = %d\n", x, y, x, y, x^y, x^y)
	fmt.Printf("x &^ y  = (%d &^ %d) = (%.8b &^ %.8b) = %.8b = %d\n", x, y, x, y, x&^y, x&^y)
	fmt.Printf("x %% y   = (%d %% %d)  = (%.8b %% %.8b)  = %.8b = %d\n", x, y, x, y, x%y, x%y)

	fmt.Println("\nБитовые операции с присваиванием")

	x = z
	x &= y
	fmt.Printf("x &= y   = (%d &= %d)  = (%.8b &= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x |= y
	fmt.Printf("x |= y   = (%d |= %d)  = (%.8b |= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x ^= y
	fmt.Printf("x ^= y   = (%d ^= %d)  = (%.8b ^= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x &^= y
	fmt.Printf("x &^= y  = (%d &^= %d) = (%.8b &^= %.8b) = %.8b = %d\n", z, y, z, y, x, x)
	x = z
	x %= y
	fmt.Printf("x %%= y   = (%d %%= %d)  = (%.8b %%= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)

	//Задание.
	//1. Пояснить результаты операций

	/*
		NOT (^x): Операція NOT інвертує кожен біт числа x. У вашому випадку, x = 9 (у двійковому представленні 0000 1001). Інвертування дасть 1111 0110, що дорівнює -10 у десятковому представленні.

		Left Shift (x << 2): Операція зсуву вліво "зсуває" біти числа x на два місця вліво. У вашому випадку, x = 9 (у двійковому представленні 0000 1001). Зсув вліво на 2 місця дасть 0010 0100, що дорівнює 36 у десятковому представленні.

		Right Shift (x >> 2): Зсув вправо "зсуває" біти числа x на два місця вправо. У вашому випадку, це дасть 0000 0010, що дорівнює 2 у десятковому представленні.

		AND (x & y): Бітова операція AND застосовується до кожної пари бітів чисел x і y. У вашому випадку, x = 9 (у двійковому представленні 0000 1001) і y = 28 (у двійковому представленні 0001 1100). Операція x & y дасть 0000 1000, що дорівнює 8.

		OR (x | y): Бітова операція OR застосовується до кожної пари бітів чисел x і y. Операція x | y дасть 0001 1101, що дорівнює 29.

		XOR (x ^ y): Бітова операція XOR застосовується до кожної пари бітів чисел x і y. Операція x ^ y дасть 0001 0100, що дорівнює 20.

		AND NOT (x &^ y): Ця операція скидає біти x, якщо відповідні біти y дорівнюють 1. Операція x &^ y дасть 0000 0001, що дорівнює 1.

		Modulus (x % y): Ця операція дає залишок від ділення x на y. Операція x % y дасть 9.

		Операції з присвоєнням: Вони працюють аналогічно, але модифікують змінну x "на місці".
	*/
}
